<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width" name=viewport><title>Un service web REST moderne, écrit en Rust, Partie I :: Barboter vers la fosse des Mariannes</title><link href=https://d34db4b3.github.io/global.css rel=stylesheet><meta content="Nous allons plonger dans la conception de back-end web avec une API REST simple, en utilisant le langage de programmation fiable et performant Rust" name=description><meta content="Un service web REST moderne, écrit en Rust, Partie I :: Barboter vers la fosse des Mariannes" property=og:title><meta content="Nous allons plonger dans la conception de back-end web avec une API REST simple, en utilisant le langage de programmation fiable et performant Rust" property=og:description><meta content=website property=og:type><meta content=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/ property=og:url><link href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/ rel=canonical><meta content=#1F1E1E name=theme-color><body><header><nav><a href=https://d34db4b3.github.io/fr>ACCEUIL</a><a href=https://d34db4b3.github.io/fr/posts>PUBLICATIONS</a><a href=https://d34db4b3.github.io/fr/tags/>MOTS CLES</a><a href=https://d34db4b3.github.io/fr/whoami>QUI SUIS-JE</a><a href=#><img class=flag src=https://d34db4b3.github.io/flags/fr.svg></a><a href=https://d34db4b3.github.io/posts/rust-rest-api-i><img class=flag src=https://d34db4b3.github.io/flags/us.svg></a></nav><hr></header><main><article><h1><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/>Un service web REST moderne, écrit en Rust, Partie I</a></h1><small> <time datetime=2022-03-06T23:51:21>March 06, 2022</time> by <a href="https://d34db4b3.github.io/fr/ @/whoami/_index.md">d34db4b3</a> </small><h4>Sommaire :</h4><ul><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#tldr>TLDR</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#introduction>Introduction</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#initialisation-du-projet>Initialisation du projet</a> <ul><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#creation-du-projet>Création du projet</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#ajout-des-librairies>Ajout des librairies</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#programme-de-test>Programme de test</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#lancement-du-programme>Lancement du programme</a></ul><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#analyse-d-une-route>Analyse d’une route</a> <ul><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#routage>Routage</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#analyse-de-la-requete>Analyse de la requête</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#analyse-de-la-reponse>Analyse de la réponse</a><li><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i/#exemple>Exemple</a></ul></ul><h1 id=tldr>TLDR</h1><blockquote><p>Nous preparons notre projet avec <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum target=_blank><code>axum</code></a> et <a rel="noopener nofollow noreferrer" href=https://docs.rs/tokio/1/tokio target=_blank><code>tokio</code></a> et nous le testons avec une simple route de bienvenue.</blockquote><h1 id=introduction>Introduction</h1><p>L’idée de ce projet est de mettre en place une API REST simple utilisant un certain nombre de fonctionnalités courantes. Il sera découpé en plusieurs parties afin de se pouvoir se focaliser sur chaque aspect.<p>Parmi elles nous verrons dans un premier temps la mise en place du serveur web, l’installation de routes et la gestion des requêtes et des réponses. Nous verrons par la suite les contraintes d’une journalisation correcte, de restriction d’accès, de traduction et de gestion de base de données.<p>Nous allons donc utiliser le langage <a rel="noopener nofollow noreferrer" href=https://www.rust-lang.org/fr target=_blank>Rust</a>, le framework<a rel="noopener nofollow noreferrer" href=https://github.com/tokio-rs/axum target=_blank>axum</a> pour gérer la partie serveur de notre API ainsi que diverses bibliothèques (crates) détaillées plus tard. Les particularités et la syntaxe de ce langage ne seront pas abordés ici.<p>La version <code>1.70.0</code> de Rust sera utilisé et il est supposé que les outils de compilation sont installés au préalable (<a rel="noopener nofollow noreferrer" href=https://www.rust-lang.org/fr/tools/install target=_blank>installation de Rust</a>).<p><a rel="noopener nofollow noreferrer" href=https://code.visualstudio.com/ target=_blank>Visual Studio Code</a> sera utilisé comme IDE tout au long du projet.<p>Afin de debugger et de tester notre API, le logiciel <a rel="noopener nofollow noreferrer" href=https://hoppscotch.io/ target=_blank>HOPPSCOTCH</a> pourra être utilisé. Les fichiers de collection seront fournis pour faciliter les tests.<p>Pour les débutants en Rust, un tutoriel sera disponible prochainement sur ce blog. En attendant, il est conseillé de lire l’excellent <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ target=_blank>livre du Rust (en anglais)</a>. (<a rel="noopener nofollow noreferrer" href=https://jimskapt.github.io/rust-book-fr/ target=_blank>version française par la communauté</a>)<p>Les particularités de sérialisation/désérialisation via <a rel="noopener nofollow noreferrer" href=https://serde.rs/ target=_blank>serde</a> ne seront pas étudiées en détail dans cet article.<p>Au cours de l’article, des instantanés du projet d’exemple seront disponibles et référenceront des commits du dépôt <a rel="noopener nofollow noreferrer" href=https://github.com/d34db4b3/rest-api-tutorial target=_blank>d34db4b3/rest-api-tutorial</a><h1 id=initialisation-du-projet>Initialisation du projet</h1><h2 id=creation-du-projet>Création du projet</h2><p>Comme pour tout projet Rust, nous allons passer par l’utilitaire <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/cargo/index.html target=_blank>cargo</a> pour initialiser la structure de nos sources. Une fois placé dans le dossier où le projet va être créé, la commande suivante va générer le dossier <code>rest-api-tutorial</code>.<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> new rest-api-tutorial
</span></code></pre><p>Le dossier nouvellement créé peut ensuite être ouvert dans Visual Studio Code.<p>Les deux fichiers qui vont nous intéresser sont <code>Cargo.toml</code> et <code>src/main.rs</code> qui sont respectivement le <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/cargo/reference/manifest.html target=_blank>manifeste de l’application</a> et le point d’entrée du programme.<pre class=language-toml data-lang=toml style=background:#2b303b;color:#c0c5ce><code class=language-toml data-lang=toml><span style=color:#65737e># Cargo.toml
</span><span>[package]
</span><span style=color:#bf616a>name </span><span>= "</span><span style=color:#a3be8c>rest-api-tutorial</span><span>"
</span><span style=color:#bf616a>version </span><span>= "</span><span style=color:#a3be8c>0.1.0</span><span>"
</span><span style=color:#bf616a>edition </span><span>= "</span><span style=color:#a3be8c>2021</span><span>"
</span><span>
</span><span>[dependencies]
</span></code></pre><pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span style=color:#65737e>// src/main.rs
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    println!("</span><span style=color:#a3be8c>Hello, world!</span><span>");
</span><span>}
</span></code></pre><p>Il est désormais possible de compiler et de lancer le programme via la commande suivante depuis le répertoire du projet.<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> run
</span></code></pre><p>Un superbe “Hello, world!” nous est présenté, mais ce n’est pas vraiment le propos de cet article.<h2 id=ajout-des-librairies>Ajout des librairies</h2><p>Nous aurons besoin de quelques dépendances, notamment <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum target=_blank><code>axum</code></a> et <a rel="noopener nofollow noreferrer" href=https://docs.rs/tokio/1/tokio target=_blank><code>tokio</code></a>. Axum fournira la plupart des fonctionnalités requises pour un serveur HTTP (routage, implémentation du protocole HTTP, middlewares, etc.) Comme il tire parti des fonctionnalités <a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/ target=_blank><code>async</code></a> de Rust, nous aurons également besoin de <code>tokio</code>, qui est un moteur d’exécution pour les applications asynchrones.<p>Ajoutens les dans le fichier de manifeste <code>Cargo.toml</code>. Pour ce faire, il faut ajouter les lignes <code>axum = "0.6"</code> and <code>tokio = { version = "1", features = ["full"] }</code> dans la catégorie <code>[dependencies]</code>. Le fichier ressemble donc à<pre class=language-toml data-lang=toml style=background:#2b303b;color:#c0c5ce><code class=language-toml data-lang=toml><span style=color:#65737e># Cargo.toml
</span><span>[package]
</span><span style=color:#bf616a>name </span><span>= "</span><span style=color:#a3be8c>rest-api-tutorial</span><span>"
</span><span style=color:#bf616a>version </span><span>= "</span><span style=color:#a3be8c>0.1.0</span><span>"
</span><span style=color:#bf616a>edition </span><span>= "</span><span style=color:#a3be8c>2021</span><span>"
</span><span>
</span><span>[dependencies]
</span><span style=color:#bf616a>axum </span><span>= "</span><span style=color:#a3be8c>0.6</span><span>"
</span><span style=color:#bf616a>tokio </span><span>= { </span><span style=color:#bf616a>version </span><span>= "</span><span style=color:#a3be8c>1</span><span>", </span><span style=color:#bf616a>features </span><span>= ["</span><span style=color:#a3be8c>full</span><span>"] }
</span></code></pre><p>Le “0.6” représente la version de <code>axum</code> à utiliser. Pour plus de détails sur les dépendances et le fichier manifest, voir [cette page] (https://doc.rust-lang.org/cargo/reference/manifest.html).<p>Les dépendances peuvent aussi (et devraient probablement pour des raisons de simplicité) être ajoutées en utilisant<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> add axum@0.6
</span><span style=color:#bf616a>cargo</span><span> add tokio@1</span><span style=color:#bf616a> -F</span><span> full
</span></code></pre><h2 id=programme-de-test>Programme de test</h2><p>Afin de vérifier la bonne configuration du manifeste et d’entamer notre aventure avec <code>axum</code>, le programme suivant peut être injecté dans le fichier <code>src/main.rs</code> à la place du “helloworld” de départ. Notre fichier ressemble donc à<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span style=color:#b48ead>use </span><span>axum::{routing::get, Router};
</span><span style=color:#b48ead>use </span><span>std::net::SocketAddr;
</span><span>
</span><span>#[</span><span style=color:#bf616a>tokio</span><span>::</span><span style=color:#bf616a>main</span><span>]
</span><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#65737e>// register a "helloworld" handler to the `/` route
</span><span>    </span><span style=color:#b48ead>let</span><span> app = Router::new().</span><span style=color:#96b5b4>route</span><span>("</span><span style=color:#a3be8c>/</span><span>", </span><span style=color:#96b5b4>get</span><span>(|| async { "</span><span style=color:#a3be8c>Hello, World!</span><span>" }));
</span><span>
</span><span>    </span><span style=color:#b48ead>let</span><span> addr = SocketAddr::from(([</span><span style=color:#d08770>127</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>1</span><span>], </span><span style=color:#d08770>3000</span><span>));
</span><span>    println!("</span><span style=color:#a3be8c>listening on http://</span><span style=color:#d08770>{}</span><span>", addr);
</span><span>    </span><span style=color:#65737e>// start the HTTP server and serve our newly created service
</span><span>    axum::Server::bind(&addr)
</span><span>        .</span><span style=color:#96b5b4>serve</span><span>(app.</span><span style=color:#96b5b4>into_make_service</span><span>())
</span><span>        .await
</span><span>        .</span><span style=color:#96b5b4>unwrap</span><span>();
</span><span>}
</span></code></pre><p>Ce programme ressemble dans sa structure au programme précédant avec sa fonction <code>main</code>, mais on observe cependant l’apparition de nouveaux mots clés tels que <code>async</code> et <code>await</code>. Ces derniers décrivent le fonctionnement asynchrone de <code>axum</code> et nous reviendrons sur ces détails plus tard. Pour l’instant nous allons nous focaliser sur le comportement de l’application.<h3 id=application>Application</h3><p>Afin que le serveur puisse faire son travail, on doit lui décrire son fonctionnement. C’est le rôle du router <code>Router</code>, sur lequel on va définir des routes, des services et ce dont il va avoir besoin pour produire le fonctionnement attendu. Ici, on lui demande d’enregistrer une route <code>/</code> (<code>.route("/", ...)</code>) sur laquelle va être greffé une fonction qui va répondre à la méthode HTTP <code>GET</code> (<code>get(...)</code>). Cette fonction décrite par un autre lambda (<code>|| async { "Hello, world! }</code>) s’occupera simplement de retourner la chaine de caractère <code>"Hello, world!"</code>.<h3 id=serveur-http>Serveur HTTP</h3><p>Ensuite, nous aurons besoin de servir notre application avec un serveur HTTP. Un <code>axum::Server</code> est lié à l’interface réseau et écoutera sur le port TCP <code>3000</code> (<code>::bind(&addr)</code>). Nous fournissons l’<code>app</code> que le serveur doit servir. Le <code>.await</code> va finalement permettre à <code>tokio</code> de “gérer” le cycle de vie de notre application.<h2 id=lancement-du-programme>Lancement du programme</h2><p>Pour faciliter le développement, l’utilitaire <code>cargo-watch</code> sera utilisé tout au long de cet article. Ce dernier permet une recompilation automatique à chaque changement du code source. Pour l’installer il suffit de faire<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> install cargo-watch
</span></code></pre><p>Ensuite le processus de compilation se lance via<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> watch</span><span style=color:#bf616a> -x</span><span> run
</span></code></pre><p>Celui-ci relancera la commande <code>cargo run</code> à chaque changement de code source.<h3 id=verification-du-fonctionnement>Vérification du fonctionnement</h3><p>Le fonctionnement attendu du programme est un serveur HTTP écoutant sur le port <code>3000</code> et répondant sur la route <code>/</code> avec le message <code>"Hello, world!"</code>. À l’aide d’un navigateur tel que Firefox, une requête sur la page <a rel="noopener nofollow noreferrer" href=http://127.0.0.1:3000/ target=_blank>http://127.0.0.1:3000/</a> devrait afficher le message<pre style=background:#2b303b;color:#c0c5ce><code><span>Hello, world!
</span></code></pre><p><a rel="noopener nofollow noreferrer" href=https://github.com/d34db4b3/rest-api-tutorial/tree/snapshots/init target=_blank>Instantané du code</a><h1 id=analyse-d-une-route>Analyse d’une route</h1><h2 id=routage>Routage</h2><p>Chaque route est associée à une fonction permettant de traiter la requête et de répondre de manière adaptée. Ces fonctions appelées <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/handler/index.html target=_blank>handlers</a> sont simplement des fonctions asynchrones qui reçoivent des extracteurs comme arguments (voir <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/index.html target=_blank><code>axum::extract</code></a>) et renvoient un objet qui doit être converti en une réponse (voir <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/response/index.html target=_blank><code>axum::response</code></a>).<h2 id=analyse-de-la-requete>Analyse de la requête</h2><p>La plupart des données de la requête sont obtenues via des “extracteurs” (type implémentant le trait <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/trait.FromRequest.html target=_blank><code>FromRequest</code></a> ou <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/trait.FromRequestParts.html target=_blank><code>FromRequestParts</code></a>). Plusieurs extracteurs sont fournis par <code>axum</code> afin de faciliter l’implémentation, mais il est possible d’en ajouter d’autres si nécessaire (ce que nous verrons avec les restrictions d’accès dans une prochaine partie). Parmi eux, nous pouvons mentionner <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/struct.Path.html target=_blank><code>Path</code></a> qui permet l’extraction de paramètres dans le chemin de la ressource, <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/struct.Query.html target=_blank><code>Query</code></a> qui de la même manière permet l’extraction des paramètres de la requête (<a rel="noopener nofollow noreferrer" href=https://developer.mozilla.org/fr/docs/Learn/Common_questions/What_is_a_URL target=_blank>plus d’informations sur les URLs</a>), <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/struct.Json.html target=_blank><code>Json</code></a> qui permet la désérialisation du corps de la requête à partir du format <a rel="noopener nofollow noreferrer" href=https://www.json.org/json-fr.html target=_blank>JSON</a> et enfin <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/struct.Form.html target=_blank><code>Form</code></a> qui a un comportement similaire à celui du format de formulaire classique encodé dans l’URL.<p>Ces extracteurs sont donnés en paramètre à nos handlers et nous permettent d’obtenir une extraction de données avec un typage statique et fiable. Les erreurs de désérialisation peuvent ainsi être correctement gérées et il sera possible d’avoir une certaine garantie sur la présence et l’exactitude des paramètres avant le traitement de la requête. Cela permet au code d’être plus robuste, clair et concis.<h2 id=analyse-de-la-reponse>Analyse de la réponse</h2><p>Afin de répondre aux requêtes, les fonctions associées aux routes doivent retourner un objet qui implémente le type [<code>IntoResponse</code>] (https://docs.rs/axum/0.6/axum/response/trait.IntoResponse.html).<p><code>axum</code> fournit par exemple le type <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/struct.Json.html target=_blank><code>Json</code></a> qui permet de transformer n’importe quel objet sérialisable en une réponse.<h2 id=exemple>Exemple</h2><h3 id=implementation>Implémentation</h3><p>Afin d’illustrer les différents éléments cités plus tôt, nous allons imaginer une route <code>/greet</code> qui via la méthode <code>GET</code> accepte en paramètres de requête un nom <code>name</code> et retournera un objet JSON contenant un message <code>greeting</code> qui contiendra la chaine formatée <code>"Hello, {}!"</code> avec le nom présent en paramètre.<p>Nous allons donc dans un premier temps définir nos types de paramètre et de réponse, implémentant respectivement désérialisation et sérialisation.<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>#[</span><span style=color:#bf616a>derive</span><span>(Deserialize)]
</span><span style=color:#b48ead>struct </span><span>GreetQuery {
</span><span>    </span><span style=color:#bf616a>name</span><span>: String,
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#bf616a>derive</span><span>(Serialize)]
</span><span style=color:#b48ead>struct </span><span>GreetResponse {
</span><span>    </span><span style=color:#bf616a>greeting</span><span>: String,
</span><span>}
</span></code></pre><p>Le type <code>GreetQuery</code> décrit donc un objet possédant un champ <code>name</code> de type <code>String</code>. Le type <code>GreetResponse</code> décrit quant à lui un objet possédant un champ <code>greeting</code> de type <code>String</code>.<p>We use the <code>Query</code> extractor on the <code>GreetQuery</code> type and the <code>Json</code> wrapper on the <code>GreetResponse</code> type. The handler thus looks like<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>greet</span><span>(</span><span style=color:#bf616a>greet_query</span><span>: Query&LTGreetQuery>) -> Json&LTGreetResponse> {
</span><span>    Json(GreetResponse {
</span><span>        greeting: format!("</span><span style=color:#a3be8c>Hello, </span><span style=color:#d08770>{}</span><span style=color:#a3be8c>!</span><span>", greet_query.name),
</span><span>    })
</span><span>}
</span></code></pre><p>Il suffit ensuite d’enregistrer la route sur notre application et notre fonction <code>main</code> ressemble désormais à<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#65737e>// register our "greeting" handler to the `/greet` route
</span><span>    </span><span style=color:#b48ead>let</span><span> app = Router::new().</span><span style=color:#96b5b4>route</span><span>("</span><span style=color:#a3be8c>/greet</span><span>", </span><span style=color:#96b5b4>get</span><span>(greet));
</span><span>
</span><span>    </span><span style=color:#b48ead>let</span><span> addr = SocketAddr::from(([</span><span style=color:#d08770>127</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>1</span><span>], </span><span style=color:#d08770>3000</span><span>));
</span><span>    println!("</span><span style=color:#a3be8c>listening on http://</span><span style=color:#d08770>{}</span><span>", addr);
</span><span>    </span><span style=color:#65737e>// start the HTTP server and serve our newly created service
</span><span>    axum::Server::bind(&addr)
</span><span>        .</span><span style=color:#96b5b4>serve</span><span>(app.</span><span style=color:#96b5b4>into_make_service</span><span>())
</span><span>        .await
</span><span>        .</span><span style=color:#96b5b4>unwrap</span><span>();
</span><span>}
</span></code></pre><h3 id=test-du-service>Test du service</h3><p>La route <code>/greet</code> devrait donc nous répondre avec un joli message sous la forme d’un document JSON.<h4 id=test-valide>Test valide</h4><p>Une requête sur la ressource <a href="http://127.0.0.1:3000/greet?name=John%20Doe" rel="noopener nofollow noreferrer" target=_blank>http://127.0.0.1:3000/greet?name=John%20Doe</a> devrait nous afficher la réponse suivante :<pre class=language-json data-lang=json style=background:#2b303b;color:#c0c5ce><code class=language-json data-lang=json><span>{
</span><span>  "</span><span style=color:#a3be8c>greeting</span><span>": "</span><span style=color:#a3be8c>Hello, John Doe!</span><span>"
</span><span>}
</span></code></pre><h4 id=test-invalide>Test invalide</h4><p>Si on essaye une requête sans le paramètre <code>name</code> <a rel="noopener nofollow noreferrer" href=http://127.0.0.1:3000/greet target=_blank>http://127.0.0.1:3000/greet</a>, on observe en revanche le message d’erreur suivant :<pre style=background:#2b303b;color:#c0c5ce><code><span>Failed to deserialize query string: missing field `name`
</span></code></pre><p>On voit donc que la requête n’est pas traitée, car les conditions ne sont pas remplies. Nous verrons plus tard comment gérer ce type d’erreur afin d’afficher un message personnalisé.<h4 id=champ-optionnel>Champ optionnel</h4><p>Il aurait aussi été possible de rendre le nom optionnel en utilisant la structure :<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>#[</span><span style=color:#bf616a>derive</span><span>(Deserialize)]
</span><span style=color:#b48ead>struct </span><span>GreetQuery {
</span><span>    </span><span style=color:#bf616a>name</span><span>: Option&LTString>,
</span><span>}
</span></code></pre><p>De cette manière, il aurait été faisable d’afficher un message par défaut, par exemple :<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>greet</span><span>(</span><span style=color:#bf616a>greet_query</span><span>: Query&LTGreetQuery>) -> Json&LTGreetResponse> {
</span><span>    Json(GreetResponse {
</span><span>        greeting: format!(
</span><span>            "</span><span style=color:#a3be8c>Hello, </span><span style=color:#d08770>{}</span><span style=color:#a3be8c>!</span><span>",
</span><span>            greet_query
</span><span>                .name
</span><span>                .</span><span style=color:#96b5b4>as_ref</span><span>()
</span><span>                .</span><span style=color:#96b5b4>map</span><span>(String::as_str)
</span><span>                .</span><span style=color:#96b5b4>unwrap_or</span><span>("</span><span style=color:#a3be8c>Anonymous</span><span>")
</span><span>        ),
</span><span>    })
</span><span>}
</span></code></pre><p>Au lieu de l’erreur lors de la requête sur <a rel="noopener nofollow noreferrer" href=http://127.0.0.1:3000/greet target=_blank>http://127.0.0.1:3000/greet</a> nous aurions alors eu la réponse suivante :<pre class=language-json data-lang=json style=background:#2b303b;color:#c0c5ce><code class=language-json data-lang=json><span>{
</span><span>  "</span><span style=color:#a3be8c>greeting</span><span>": "</span><span style=color:#a3be8c>Hello, Anonymous!</span><span>"
</span><span>}
</span></code></pre><p><a rel="noopener nofollow noreferrer" href=https://github.com/d34db4b3/rest-api-tutorial/tree/snapshots/greetings target=_blank>Instantané du code</a><blockquote><p>Félicitation, l’introduction est terminée, la procahine partie est en cours de rédaction.</blockquote></article></main><footer>Proudly built with <a href=https://www.getzola.org/>Zola</a></footer>