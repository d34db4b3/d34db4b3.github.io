<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width" name=viewport><title>A modern REST web service, written in Rust, Part I :: Paddling towards the Mariana Trench</title><link href=https://d34db4b3.github.io/global.css rel=stylesheet><meta content="We will dive into web back-end design with a simple REST API, using the reliable and efficient programming language Rust" name=description><meta content="A modern REST web service, written in Rust, Part I :: Paddling towards the Mariana Trench" property=og:title><meta content="We will dive into web back-end design with a simple REST API, using the reliable and efficient programming language Rust" property=og:description><meta content=website property=og:type><meta content=https://d34db4b3.github.io/posts/rust-rest-api-i/ property=og:url><link href=https://d34db4b3.github.io/posts/rust-rest-api-i/ rel=canonical><meta content=#1F1E1E name=theme-color><body><header><nav><a href=https://d34db4b3.github.io>HOME</a><a href=https://d34db4b3.github.io/posts>POSTS</a><a href=https://d34db4b3.github.io/tags/>TAGS</a><a href=https://d34db4b3.github.io/whoami>WHOAMI</a><a href=https://d34db4b3.github.io/fr/posts/rust-rest-api-i><img class=flag src=https://d34db4b3.github.io/flags/fr.svg></a><a href=#><img class=flag src=https://d34db4b3.github.io/flags/us.svg></a></nav><hr></header><main><article><h1><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/>A modern REST web service, written in Rust, Part I</a></h1><small> <time datetime=2022-03-06T23:51:21>March 06, 2022</time> by <a href="https://d34db4b3.github.io/ @/whoami/_index.md">d34db4b3</a> </small><h4>Summary:</h4><ul><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#tldr>TLDR</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#introduction>Introduction</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#project-initialization>Project initialization</a> <ul><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#project-creation>Project creation</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#adding-crates>Adding crates</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#test-program>Test program</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#running-the-program>Running the program</a></ul><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#analysis-of-a-handler>Analysis of a handler</a> <ul><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#routing>Routing</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#request-analysis>Request analysis</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#response-analysis>Response analysis</a><li><a href=https://d34db4b3.github.io/posts/rust-rest-api-i/#example>Example</a></ul></ul><h1 id=tldr>TLDR</h1><blockquote><p>We setup our project with <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum target=_blank><code>axum</code></a> and <a rel="noopener nofollow noreferrer" href=https://docs.rs/tokio/1/tokio target=_blank><code>tokio</code></a> and test it with a simple “greetings” endpoint.</blockquote><h1 id=introduction>Introduction</h1><p>The idea of this project is to implement a simple REST API using a number of common features. It will be split in several parts in order to focus on each aspect.<p>Among them, we will first see the setting up of the web server, the routes registration and the management of requests and responses. We will then see the various challenges of proper logging, access restriction, internationalization and database management.<p>We will use the <a rel="noopener nofollow noreferrer" href=https://www.rust-lang.org/ target=_blank>Rust</a> language, the <a rel="noopener nofollow noreferrer" href=https://github.com/tokio-rs/axum target=_blank>axum</a> framework to manage most of the HTTP server functionalities of our API and various other libraries (crates) detailed later. The particularities and the syntax of this language will not be discussed here.<p>Provided commands will assume a linux host.<p>Rust version <code>1.70.0</code> will be used and it is assumed that the build tools are installed beforehand (<a rel="noopener nofollow noreferrer" href=https://www.rust-lang.org/tools/install target=_blank>Rust installation</a>).<p><a rel="noopener nofollow noreferrer" href=https://code.visualstudio.com/ target=_blank>Visual Studio Code</a> will be used as an IDE throughout the project.<p>In order to debug and test our API, the <a rel="noopener nofollow noreferrer" href=https://hoppscotch.io/ target=_blank>HOPPSCOTCH</a> software can be used. The collection files will be provided for easier testing.<p>For beginners in Rust, a tutorial will be available soon on this blog. In the meantime, it is recommended to read the excellent <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/book/ target=_blank>Rust book</a>.<p>The particularities of serialization/deserialization via <a rel="noopener nofollow noreferrer" href=https://serde.rs/ target=_blank>serde</a> will not be studied in detail in this article.<p>During the course of the article, snapshots of the example project will be available and will consist of branches from the <a rel="noopener nofollow noreferrer" href=https://github.com/d34db4b3/rest-api-tutorial target=_blank>d34db4b3/rest-api-tutorial</a> repository.<h1 id=project-initialization>Project initialization</h1><h2 id=project-creation>Project creation</h2><p>As for any Rust project, we will use the <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/cargo/index.html target=_blank>cargo</a> utility to initialize the sources structure. Once placed in the folder where the project will be created, the following command will generate the <code>rest-api-tutorial</code> project.<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> new rest-api-tutorial
</span></code></pre><p>The newly created folder can then be opened in Visual Studio Code.<p>The two files we are interested in are <code>Cargo.toml</code> and <code>src/main.rs</code> which are respectively the <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/cargo/reference/manifest.html target=_blank>application manifest</a> and the entry point of the program.<pre class=language-toml data-lang=toml style=background:#2b303b;color:#c0c5ce><code class=language-toml data-lang=toml><span style=color:#65737e># Cargo.toml
</span><span>[package]
</span><span style=color:#bf616a>name </span><span>= "</span><span style=color:#a3be8c>rest-api-tutorial</span><span>"
</span><span style=color:#bf616a>version </span><span>= "</span><span style=color:#a3be8c>0.1.0</span><span>"
</span><span style=color:#bf616a>edition </span><span>= "</span><span style=color:#a3be8c>2021</span><span>"
</span><span>
</span><span>[dependencies]
</span></code></pre><pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span style=color:#65737e>// src/main.rs
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    println!("</span><span style=color:#a3be8c>Hello, world!</span><span>");
</span><span>}
</span></code></pre><p>It is now possible to compile and run the program with the following command from the project directory.<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> run
</span></code></pre><p>A beautiful “Hello, world!” is presented to us, but it is not really the subject of this article.<h2 id=adding-crates>Adding crates</h2><p>We will need a few dependencies, notably <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum target=_blank><code>axum</code></a> and <a rel="noopener nofollow noreferrer" href=https://docs.rs/tokio/1/tokio target=_blank><code>tokio</code></a>. Axum will provide most of the features required for an HTTP server (routing, HTTP protocol implementation, middlewares, etc.). As it takes advantages of the <a rel="noopener nofollow noreferrer" href=https://rust-lang.github.io/async-book/ target=_blank><code>async</code></a> Rust features, we will also need <code>tokio</code>, which is a runtime for asynchronous applications.<p>Let’s add those in the <code>Cargo.toml</code> manifest file. To do this, insert the lines <code>axum = "0.6"</code> and <code>tokio = { version = "1", features = ["full"] }</code> to the category <code>[dependencies]</code>. The file then looks like<pre class=language-toml data-lang=toml style=background:#2b303b;color:#c0c5ce><code class=language-toml data-lang=toml><span style=color:#65737e># Cargo.toml
</span><span>[package]
</span><span style=color:#bf616a>name </span><span>= "</span><span style=color:#a3be8c>rest-api-tutorial</span><span>"
</span><span style=color:#bf616a>version </span><span>= "</span><span style=color:#a3be8c>0.1.0</span><span>"
</span><span style=color:#bf616a>edition </span><span>= "</span><span style=color:#a3be8c>2021</span><span>"
</span><span>
</span><span>[dependencies]
</span><span style=color:#bf616a>axum </span><span>= "</span><span style=color:#a3be8c>0.6</span><span>"
</span><span style=color:#bf616a>tokio </span><span>= { </span><span style=color:#bf616a>version </span><span>= "</span><span style=color:#a3be8c>1</span><span>", </span><span style=color:#bf616a>features </span><span>= ["</span><span style=color:#a3be8c>full</span><span>"] }
</span></code></pre><p>The “0.6” represents the version of <code>axum</code> to use. For more details on dependencies and the manifest file, see <a rel="noopener nofollow noreferrer" href=https://doc.rust-lang.org/cargo/reference/manifest.html target=_blank>this page</a>.<p>Dependencies can also (and probably should for simplicity sake) be added using<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> add axum@0.6
</span><span style=color:#bf616a>cargo</span><span> add tokio@1</span><span style=color:#bf616a> -F</span><span> full
</span></code></pre><h2 id=test-program>Test program</h2><p>In order to check the correct configuration of the manifest and to start our adventure with <code>axum</code>, the following program can be injected into the <code>src/main.rs</code> file instead of the starting “helloworld”. Our file looks like this<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span style=color:#b48ead>use </span><span>axum::{routing::get, Router};
</span><span style=color:#b48ead>use </span><span>std::net::SocketAddr;
</span><span>
</span><span>#[</span><span style=color:#bf616a>tokio</span><span>::</span><span style=color:#bf616a>main</span><span>]
</span><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#65737e>// register a "helloworld" handler to the `/` route
</span><span>    </span><span style=color:#b48ead>let</span><span> app = Router::new().</span><span style=color:#96b5b4>route</span><span>("</span><span style=color:#a3be8c>/</span><span>", </span><span style=color:#96b5b4>get</span><span>(|| async { "</span><span style=color:#a3be8c>Hello, World!</span><span>" }));
</span><span>
</span><span>    </span><span style=color:#b48ead>let</span><span> addr = SocketAddr::from(([</span><span style=color:#d08770>127</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>1</span><span>], </span><span style=color:#d08770>3000</span><span>));
</span><span>    println!("</span><span style=color:#a3be8c>listening on http://</span><span style=color:#d08770>{}</span><span>", addr);
</span><span>    </span><span style=color:#65737e>// start the HTTP server and serve our newly created service
</span><span>    axum::Server::bind(&addr)
</span><span>        .</span><span style=color:#96b5b4>serve</span><span>(app.</span><span style=color:#96b5b4>into_make_service</span><span>())
</span><span>        .await
</span><span>        .</span><span style=color:#96b5b4>unwrap</span><span>();
</span><span>}
</span></code></pre><p>This program resembles the structure of the previous program with its <code>main</code> function, but there are some new keywords such as <code>async</code> and <code>await</code>. These describe the asynchronous operation of <code>axum</code> and we will come back to these details later. For now we will focus on the behavior of the application.<h3 id=application>Application</h3><p>In order for the server to do its job, we need to describe how it should work. This is the role of the <code>Router</code>, on which we will define routes, services and what it will need to do its job. Here, we ask it to register a <code>/</code> route (<code>.route("/", ...)</code>) on which a function will be grafted that will respond to the HTTP <code>GET</code> method (<code>get(...)</code>). This function described by a lambda (<code>|| async { "Hello, World!" }</code>) will simply return the string <code>"Hello, world!"</code>. A lambda is an unnamed function, used here to limit the size of the code and the amount of information present for the sake of clarity.<h3 id=http-server>Http server</h3><p>Then, we will need to serve our app with an HTTP server. An <code>axum::Server</code> is bound to the network interface and will listen on the TCP port <code>3000</code> (<code>::bind(&addr)</code>). We provide the <code>app</code> for the server to serve. The <code>.await</code> will finally let <code>tokio</code> “manage” the lifecycle of our app.<h2 id=running-the-program>Running the program</h2><p>To facilitate development, the <code>cargo-watch</code> utility will be used throughout this article. This utility allows an automatic recompilation at each change of the source code. To install it, just do<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> install cargo-watch
</span></code></pre><p>Then the compilation process starts via<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> watch</span><span style=color:#bf616a> -x</span><span> run
</span></code></pre><p>This will re-run the <code>cargo run</code> command every time the source code changes.<h3 id=checking-the-behavior>Checking the behavior</h3><p>The expected operation of the program is an HTTP server listening on port <code>3000</code> and responding on route <code>/</code> with the message <code>"Hello, world!"</code>. Using a browser such as Firefox, a request to the <a rel="noopener nofollow noreferrer" href=http://127.0.0.1:3000/ target=_blank>http://127.0.0.1:3000/</a> page should display the message<pre style=background:#2b303b;color:#c0c5ce><code><span>Hello, world!
</span></code></pre><p><a rel="noopener nofollow noreferrer" href=https://github.com/d34db4b3/rest-api-tutorial/tree/snapshots/init target=_blank>Source code snapshot</a><h1 id=analysis-of-a-handler>Analysis of a handler</h1><h2 id=routing>Routing</h2><p>Each route is associated with a function to process the request and respond appropriately. These functions called <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/handler/index.html target=_blank>handlers</a> are simply asynchronous functions that are given extractors as arguments (see <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/index.html target=_blank><code>axum::extract</code></a>) and return an object that must be convertible into a response (see <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/response/index.html target=_blank><code>axum::response</code></a>).<h2 id=request-analysis>Request analysis</h2><p>Most of the request data is obtained via “extractors” (a type implementing the <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/trait.FromRequest.html target=_blank><code>FromRequest</code></a> or <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/trait.FromRequestParts.html target=_blank><code>FromRequestParts</code></a> trait). Several extractors are provided by <code>axum</code> in order to ease the implementation, but it is possible to add more as needed (which we will see with access restrictions in a next part). Among them we can mention <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/struct.Path.html target=_blank><code>Path</code></a> allowing the extraction of parameters in the path of the resource, <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/extract/struct.Query.html target=_blank><code>Query</code></a> which in the same way allows the extraction of the parameters of the request (<a rel="noopener nofollow noreferrer" href=https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL target=_blank>more information on URLs</a>), <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/struct.Json.html target=_blank><code>Json</code></a> which allows the deserialization of the request body from the <a rel="noopener nofollow noreferrer" href=https://www.json.org/json-en.html target=_blank>JSON</a> format and finally <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/struct.Form.html target=_blank><code>Form</code></a> which has a similar behavior from the classic URL-encoded form format.<p>These extractors are given as parameters to our handlers and allow us to obtain data extraction with static and safe typing. The deserialization errors can thus be properly managed and it will be possible to have some guarantee over the presence and correctness of parameters before the processing of the request. This allows the code to be more robust, clear and concise.<h2 id=response-analysis>Response analysis</h2><p>In order to respond to requests, functions associated with routes must return an object that implements <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/response/trait.IntoResponse.html target=_blank><code>IntoResponse</code></a>.<p><code>axum</code> provides for example the <a rel="noopener nofollow noreferrer" href=https://docs.rs/axum/0.6/axum/struct.Json.html target=_blank><code>Json</code></a> type which allows to transform any serializable object into a response.<h2 id=example>Example</h2><h3 id=implementation>Implementation</h3><p>In order to illustrate the different elements mentioned earlier, we will imagine a <code>/greet</code> route which via the <code>GET</code> method accepts as request parameters a name <code>name</code> and will return a JSON object containing a <code>greeting</code> message which will contain the formatted string <code>"Hello, {}!"</code> with the <code>name</code> present as parameter.<p>We will therefore first define our parameters and response types, implementing respectively deserialization and serialization.<p>We need te bring the <a rel="noopener nofollow noreferrer" href=https://serde.rs/ target=_blank><code>serde</code></a> framework.<pre class=language-sh data-lang=sh style=background:#2b303b;color:#c0c5ce><code class=language-sh data-lang=sh><span style=color:#bf616a>cargo</span><span> add serde@1.0</span><span style=color:#bf616a> -F</span><span> derive
</span></code></pre><p>The code looks like this<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>#[</span><span style=color:#bf616a>derive</span><span>(Deserialize)]
</span><span style=color:#b48ead>struct </span><span>GreetQuery {
</span><span>    </span><span style=color:#bf616a>name</span><span>: String,
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#bf616a>derive</span><span>(Serialize)]
</span><span style=color:#b48ead>struct </span><span>GreetResponse {
</span><span>    </span><span style=color:#bf616a>greeting</span><span>: String,
</span><span>}
</span></code></pre><p>The <code>GreetQuery</code> type describes an object with a <code>name</code> field of type <code>String</code>. The <code>GreetResponse</code> type describes an object with a <code>greeting</code> field of type <code>String</code>.<p>We use the <code>Query</code> extractor on the <code>GreetQuery</code> type and the <code>Json</code> wrapper on the <code>GreetResponse</code> type. The handler thus looks like<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>greet</span><span>(</span><span style=color:#bf616a>greet_query</span><span>: Query&LTGreetQuery>) -> Json&LTGreetResponse> {
</span><span>    Json(GreetResponse {
</span><span>        greeting: format!("</span><span style=color:#a3be8c>Hello, </span><span style=color:#d08770>{}</span><span style=color:#a3be8c>!</span><span>", greet_query.name),
</span><span>    })
</span><span>}
</span></code></pre><p>Then we just need to register the route on our application and our <code>main</code> function now looks like<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>#[</span><span style=color:#bf616a>tokio</span><span>::</span><span style=color:#bf616a>main</span><span>]
</span><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#65737e>// register our "greeting" handler to the `/greet` route
</span><span>    </span><span style=color:#b48ead>let</span><span> app = Router::new().</span><span style=color:#96b5b4>route</span><span>("</span><span style=color:#a3be8c>/greet</span><span>", </span><span style=color:#96b5b4>get</span><span>(greet));
</span><span>
</span><span>    </span><span style=color:#b48ead>let</span><span> addr = SocketAddr::from(([</span><span style=color:#d08770>127</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>1</span><span>], </span><span style=color:#d08770>3000</span><span>));
</span><span>    println!("</span><span style=color:#a3be8c>listening on http://</span><span style=color:#d08770>{}</span><span>", addr);
</span><span>    </span><span style=color:#65737e>// start the HTTP server and serve our newly created service
</span><span>    axum::Server::bind(&addr)
</span><span>        .</span><span style=color:#96b5b4>serve</span><span>(app.</span><span style=color:#96b5b4>into_make_service</span><span>())
</span><span>        .await
</span><span>        .</span><span style=color:#96b5b4>unwrap</span><span>();
</span><span>}
</span></code></pre><h3 id=service-test>Service test</h3><p>The <code>/greet</code> route should therefore respond with a nice message in the form of a JSON document.<h4 id=valid-test>Valid test</h4><p>A query on the <a href="http://127.0.0.1:3000/greet?name=John%20Doe" rel="noopener nofollow noreferrer" target=_blank>http://127.0.0.1:3000/greet?name=John%20Doe</a> resource should show us the following response:<pre class=language-json data-lang=json style=background:#2b303b;color:#c0c5ce><code class=language-json data-lang=json><span>{
</span><span>  "</span><span style=color:#a3be8c>greeting</span><span>": "</span><span style=color:#a3be8c>Hello, John Doe!</span><span>"
</span><span>}
</span></code></pre><h4 id=invalid-test>Invalid test</h4><p>If we try a query without the <code>name</code> parameter <a rel="noopener nofollow noreferrer" href=http://127.0.0.1:3000/greet target=_blank>http://127.0.0.1:3000/greet</a>, we instead see the following error message:<pre style=background:#2b303b;color:#c0c5ce><code><span>Failed to deserialize query string: missing field `name`
</span></code></pre><p>We see that the request is not process because the required parameters are not present and get a default error. We will later see how we can customize this behavior (to get a JSON error far example)<h4 id=optional-field>Optional field</h4><p>It would also have been possible to make the name optional by using the :<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>#[</span><span style=color:#bf616a>derive</span><span>(Deserialize)]
</span><span style=color:#b48ead>struct </span><span>GreetQuery {
</span><span>    </span><span style=color:#bf616a>name</span><span>: Option&LTString>,
</span><span>}
</span></code></pre><p>In this way, it would have been feasible to display a default name, for example :<pre class=language-rs data-lang=rs style=background:#2b303b;color:#c0c5ce><code class=language-rs data-lang=rs><span>async </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>greet</span><span>(</span><span style=color:#bf616a>greet_query</span><span>: Query&LTGreetQuery>) -> Json&LTGreetResponse> {
</span><span>    Json(GreetResponse {
</span><span>        greeting: format!(
</span><span>            "</span><span style=color:#a3be8c>Hello, </span><span style=color:#d08770>{}</span><span style=color:#a3be8c>!</span><span>",
</span><span>            greet_query
</span><span>                .name
</span><span>                .</span><span style=color:#96b5b4>as_ref</span><span>()
</span><span>                .</span><span style=color:#96b5b4>map</span><span>(String::as_str)
</span><span>                .</span><span style=color:#96b5b4>unwrap_or</span><span>("</span><span style=color:#a3be8c>Anonymous</span><span>")
</span><span>        ),
</span><span>    })
</span><span>}
</span></code></pre><p>Instead of the error when requesting <a rel="noopener nofollow noreferrer" href=http://127.0.0.1:3000/greet target=_blank>http://127.0.0.1:3000/greet</a> we would then have had the following response:<pre class=language-json data-lang=json style=background:#2b303b;color:#c0c5ce><code class=language-json data-lang=json><span>{
</span><span>  "</span><span style=color:#a3be8c>greeting</span><span>": "</span><span style=color:#a3be8c>Hello, Anonymous!</span><span>"
</span><span>}
</span></code></pre><p><a rel="noopener nofollow noreferrer" href=https://github.com/d34db4b3/rest-api-tutorial/tree/snapshots/greetings target=_blank>Source code snapshot</a><blockquote><p>Congratulations, this is the end of the introduction, the next part is being written.</blockquote></article></main><footer>Proudly built with <a href=https://www.getzola.org/>Zola</a></footer>